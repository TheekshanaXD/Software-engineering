#                 <u>Design And Implementation</u>

Architectural design is the initial phase of software designing

![image-20250417110940933](./assets/image-20250417110940933.png)

![image-20250417111000237](./assets/image-20250417111000237.png)

> [!TIP]
>
> ## **Chapter: Software Design and Implementation**
>
> ### **Overview**
>
> - **Software design and implementation** is the phase where the system becomes an **executable product**.
> - For **simple systems**, this may include all software engineering activities.
> - For **large systems**, it's one part of a broader process (includes requirements, verification, validation, etc.).
>
> ------
>
> ### **Key Concepts**
>
> #### ðŸ”§ **Design and Implementation Interleaving**
>
> - These activities are **tightly interwoven**.
> - **Design** involves identifying components and their relationships based on customer requirements.
> - **Implementation** is the realization of the design into code.
>
> #### ðŸŽ¨ **Nature of Design**
>
> - Can range from formal UML models to informal sketches or mental models.
> - **Always** present, even if not explicitly documented.
> - Design is about how  to solve a problem, so there is always a design process. However, it isnâ€™t always necessary or appropriate to describe the design in detail using the UML or other design  description language.
>
> #### ðŸ§  **Consider Implementation Early**
>
> - The design should **consider the language and environment**:
>   - UML is helpful for **Java/C#** (OOP languages).
>   - Less useful for **Python** or **configuration-based systems**.
> - **Agile methods** often rely on informal designs handled by developers.
>
> ------
>
> ### **Build or Buy Decision**
>
> - A **critical early decision**:
>   - Should you **build** the software or **buy** an off-the-shelf solution?
> - Buying is often:
>   - **Faster** and **cheaper**
>   - Common in domains like **medical systems**
> - <u>**Design focus** then shifts to **configuration** rather than full system modeling.</u>
>
> ------
>
> ### **Reuse-Based Development**
>
> - When reusing software products:
>   - Focus is on **adapting existing systems**
>   - **Object interaction models** may not be created
> - Further discussed in **Chapter 15**
>
> ------
>
> ### **Assumed Background**
>
> - Readers are assumed to have:
>   - Experience with **programming languages** (e.g., Java, Python)
>   - Understanding of **debugging** and **good coding practices**
> - This chapter **does not cover basic programming**.
>
> ------
>
> ### **Chapter Goals**
>
> 1. Show how **system modeling and architecture design** are applied in object-oriented design
> 2. Introduce **implementation concerns** like:
>    - Software **reuse**
>    - **Configuration management**
>    - **Open-source** development
>
> ------
>
> ### **Neutral Platform**
>
> - No specific programming language is favored.
> - **UML** is used for examples to keep content general.



# 7.1 Object - oriented design using UML

> [!TIP]
>
> ### ðŸ§© **Core Concepts**
>
> <img src="./assets/image-20250417120026805.png" alt="image-20250417120026805" style="zoom:50%;" />
>
> - An **object-oriented system** is built from **interacting objects**.
> - Each object:
>   - Maintains **its own private state**
>   - Offers **operations** (methods) to interact with that state
>   - Hides internal representation (encapsulation)
>
> ------
>
> ### âš™ï¸ **Object-Oriented Design (OOD)**
>
> - **Objects** are defined by **classes**.
> - Classes describe:
>   - **Attributes** (data/state)
>   - **Methods** (operations)
> - When executed, **objects are instantiated** from these class definitions.
> - Objects:
>   - Can be **understood/modified independently**
>   - Are **loosely coupled**, reducing system-wide impact when changes occur
>   - Often map to **real-world entities**, making systems easier to understand and maintain
>
> ------
>
> ### ðŸ› ï¸ **OOD Process Steps**
>
> To move from a **concept** to a **detailed object-oriented design**, follow these general steps:
>
> > 1. **Define the system context and interactions** 
> >     â€“ Identify the systemâ€™s boundaries and its external interactions.
> > 2. **Design the system architecture**
> >     â€“ Establish the high-level structure and components.
> > 3. **Identify principal objects**
> >     â€“ Determine the main classes/entities in the system.
> > 4. **Develop design models**
> >     â€“ Use tools like **UML** to visualize classes, relationships, interactions, etc.
> > 5. **Specify interfaces**
> >     â€“ Define how objects communicate (method signatures, parameters, etc.).
>
> ------
>
> ### ðŸ’¡ **Nature of Design Work**
>
> - Design is **creative** and **iterative**:
>   - Itâ€™s **not strictly linear**â€”expect backtracking and revisiting earlier decisions.
>   - Sometimes details are explored early; other times, theyâ€™re deferred.
>   - **UML and other notations** can be:
>     - Used **formally** for clarity and documentation
>     - Used **informally** for brainstorming and collaboration+
>
> example
>
>  I explain object-oriented software design by developing a design for part of the  embedded software for the wilderness weather station that I introduced in Chapter 1.  
>
> Wilderness weather stations are deployed in remote areas. Each weather station  records local weather information and periodically transfers this to a weather information system, using a satellite link
>
> ![image-20250417124012803](./assets/image-20250417124012803.png)



## 7.1.1  System context and interactions

![image-20250417124430692](./assets/image-20250417124430692.png)

#### system context model

![image-20250417124012803](./assets/image-20250417124012803.png)

![image-20250417130109240](./assets/image-20250417130109240.png)



#### Interactional model

![image-20250417130126205](./assets/image-20250417130126205.png)

![image-20250417130151195](./assets/image-20250417130151195.png)

<img src="./assets/image-20250417130549600.png" alt="image-20250417130549600" style="zoom:50%;" /> <img src="./assets/image-20250417131054897.png" alt="image-20250417131054897" style="zoom:50%;" />



<img src="./assets/image-20250417130224698.png" alt="image-20250417130224698" style="zoom: 50%;" />

<img src="./assets/image-20250417130232068.png" alt="image-20250417130232068" style="zoom:50%;" />

<img src="./assets/image-20250417131155177.png" alt="image-20250417131155177" style="zoom:50%;" />

## 7.1.2 Architectural design

> To build the architecture we only need context and interactional models, other models are developed in later phases.

-  Once the interactions between the software system and the systemâ€™s environment  have been defined, you use this information as a basis for designing the system architecture. 
- Of course, you need to combine this knowledge with your general knowledge of the principles of architectural design and with more detailed domain  knowledge. 
- You identify the major components that make up the system and their  interactions. You may then design the system organization using an architectural  pattern such as a layered or clientâ€“server model.

> [!WARNING]
>
> The high-level architectural design for the <u>weather station</u> software is shown in  Figure 7.4. 
>
> ![image-20250417131821254](./assets/image-20250417131821254.png)
>
> - The weather station is composed of independent subsystems that  communicate by broadcasting messages on a common infrastructure, shown as Communication link in  Figure 7.4.
> -  Each subsystem listens for messages on that infrastructure and picks up the  messages that are intended for them. ==This â€œlistener modelâ€ is a commonly used architectural style for distributed systems.==
> -  When the communications subsystem receives a control command, such as shut down, the command is picked up by each of the other subsystems, which then shut  themselves down in the correct way. 
> - ==The key benefit of this architecture is that it is  easy to support different configurations of subsystems because the sender of a message does not need to address the message to a particular subsystem.==
>
> <img src="./assets/image-20250417132605517.png" alt="image-20250417132605517" style="zoom:50%;" />
>
> -  Figure 7.5 shows the architecture of the data collection subsystem, which is included  in Figure 7.4. The Transmitter and Receiver objects are concerned with managing  communications, and the WeatherData object encapsulates the information that is collected from the instruments and transmitted to the weather information system. This  arrangement follows the producerâ€“consumer pattern, discussed in Chapter 21.
>
> ![image-20250417132945046](./assets/image-20250417132945046.png)

 

## 7.1.3 Object class identification

 By this stage in the design process, you should have some ideas about the essential  objects in the system that you are designing. As your understanding of the design  develops, you refine these ideas about the system objects. 

The use case description  helps to identify objects and operations in the system. <u>From the description of the  Report weather use case, it is obvious that you will need to implement objects representing the instruments that collect weather data and an object representing the  summary of the weather data.</u> 

You also usually need a high-level system object or  objects that encapsulate the system interactions defined in the use cases. With these  objects in mind, you can start to identify the general object classes in the system. 

As object-oriented design evolved in the 1980s, various ways of identifying  object classes in object-oriented systems were suggested

#### 1. Grammatical analysis

#### 2. Tangible and conceptual entities

#### 3. Scenario based analysis

> [!NOTE]
>
> ## ðŸ” **Methods for Identifying Object Classes in OO Design**
>
> ### **1. Grammatical Analysis**
>
> **(Abbott, 1983)**
>
> - Based on analyzing **natural language descriptions** of system requirements.
> - **Nouns** â†’ Candidate **classes** or **attributes**
> - **Verbs** â†’ Candidate **methods** or **operations**
>
> #### âœ… Example:
>
> From the sentence *"The manager approves leave requests."*
>
> - **Nouns**: manager, leave, request â†’ candidate classes
> - **Verbs**: approves â†’ candidate operation (e.g., `approveRequest()`)
>
> > ðŸ§  Use Case: Best for early requirement documents written in plain English.
>
> ------
>
> ### **2. Tangible & Conceptual Entities**
>
> **(Wirfs-Brock, Wilkerson, and Weiner, 1990)**
>
> - Identify objects based on **domain-specific concepts**.
> - These include:
>   - **Tangible entities** (e.g., aircraft, employees)
>   - **Roles** (e.g., manager, student)
>   - **Events** (e.g., login, request)
>   - **Interactions** (e.g., meetings, messages)
>   - **Locations** (e.g., office, server room)
>   - **Organizational units** (e.g., departments, companies)
>
> > ðŸ§  Use Case: Great for domain-driven design and aligning software closely with real-world systems.
>
> ------
>
> ### **3. Scenario-Based Analysis**
>
> **(Beck & Cunningham, 1989)**
>
> - Analyze **user interaction scenarios** (often written as use cases).
> - For each scenario, extract:
>   - **Objects** (participants in the scenario)
>   - **Attributes** (data held by the objects)
>   - **Operations** (actions the objects perform)
>
> #### âœ… Example:
>
> Scenario: A customer places an order online.
>
> - Objects: customer, order, shopping cart, product
> - Attributes: customer name, order ID
> - Operations: addProduct(), confirmOrder(), etc.
>
> > ðŸ§  Use Case: Common in **agile development** and **use-case-driven modeling**.
>
> ------
>
> ### ðŸ§  Summary Table
>
> 
>
> | Method                   | Key Idea                                      | Best For                               |
> | ------------------------ | --------------------------------------------- | -------------------------------------- |
> | **Grammatical Analysis** | Use nouns/verbs in text to find classes       | Early requirement docs                 |
> | **Tangible Entities**    | Identify real-world or domain-specific things | Domain-driven and conceptual design    |
> | **Scenario-Based**       | Extract from system usage scenarios           | Agile modeling, use-case driven design |
>
> ------
>
> 
>
> ## ðŸ”§ **Practical Approach to Discovering Object Classes**
>
> ### âœ… 1. **Use Multiple Knowledge Sources**
>
> No single technique is sufficientâ€”effective class identification pulls from:
>
> - **Grammatical analysis** (from natural language descriptions)
> - **Domain knowledge** (understanding real-world entities)
> - **Scenarios and use cases** (user stories and workflows)
> - **Stakeholder input** (conversations with users, SMEs)
> - **Legacy systems** (looking at how similar problems were solved)
>
> ------
>
> ### âœ… 2. **Start with What You Know**
>
> - Use **initial classes, attributes, and operations** identified from informal requirements.
> - These become the **seed elements** of your object model.
>
> > Think of this as a **first draft**â€”it gets you going, but it will evolve.
>
> ------
>
> ### âœ… 3. **Refine and Expand Through Domain Analysis**
>
> - Domain concepts may reveal hidden complexity:
>   - A â€œUserâ€ might later split into â€œAdmin,â€ â€œGuest,â€ and â€œRegisteredUser.â€
> - **Scenarios** reveal additional responsibilities and operations (e.g., edge cases, exception flows).
>
> ------
>
> ### âœ… 4. **Donâ€™t Forget Implementation Objects**
>
> - These arenâ€™t tied to domain entities, but are essential for making the system work.
>
> Examples:
>
> 
>
> | Purpose                | Example Implementation Object   |
> | ---------------------- | ------------------------------- |
> | **Searching**          | `SearchService`, `FilterEngine` |
> | **Validation**         | `Validator`, `RulesEngine`      |
> | **Formatting/Parsing** | `Formatter`, `Parser`           |
> | **Utility Functions**  | `DateHelper`, `StringUtils`     |
>
> > ðŸ§  These are often **internal-use classes**, but theyâ€™re critical to architecture and maintainability.
>
> ------
>
> ### ðŸŽ¯ Summary
>
> 
>
> | Step                       | Goal                                              |
> | -------------------------- | ------------------------------------------------- |
> | Use informal descriptions  | Identify candidate classes/operations             |
> | Apply domain knowledge     | Refine based on real-world entities and behaviors |
> | Analyze scenarios          | Discover interactions, responsibilities           |
> | Add implementation objects | Support system-level functionality                |

ex: 

-  In the wilderness weather station, <u>object identification is based on the tangible hardware in the system(2^nd^ method)</u>.

-  I donâ€™t have space to include all the system objects here, but  I have shown five object classes in Figure 7.6. 

  - The Ground thermometer,  Anemometer, and Barometer objects are application domain objects,
  -  and the  WeatherStation and WeatherData objects have been identified from the system description and the scenario (use case) description

  ![image-20250417153414015](./assets/image-20250417153414015.png)

  > 1. The WeatherStation object class provides the basic interface of the weather station with its environment. Its operations are based on the interactions shown in  Figure 7.2. I use a single object class, and it includes all of these interactions.  Alternatively, you could design the system interface as several different classes,  with one class per interaction.
  > 2. The WeatherData object class is responsible for processing the report weather  command. It sends the summarized data from the weather station instruments to  the weather information system.
  > 3. The Ground thermometer, Anemometer, and Barometer object classes are directly  related to instruments in the system. They reflect tangible hardware entities in the  system and the operations are concerned with controlling that hardware. These  objects operate autonomously to collect data at the specified frequency and store the  collected data locally. This data is delivered to the WeatherData object on request.
  >
  > ![image-20250417154018011](./assets/image-20250417154018011.png)
  >
  > - At this stage in the design process, you should focus on the objects themselves, without thinking about how these objects might be implemented. 
  > - Once you have identified  the objects, you then refine the object design. You look for common features and then  design the inheritance hierarchy for the system. For example, you may identify an  Instrument superclass, which defines the common features of all instruments, such as an  identifier, and get and test operations. You may also add new attributes and operations  to the superclass, such as an attribute that records how often data should be collected.



## 7.1.4 Design models

-  Design or system models, as I discussed in Chapter 5, show the objects or object classes  in a system. They also show the associations and relationships between these entities.

- An important step in the design process, therefore, is to decide on the design models  that you need and the level of detail required in these models. This depends on the type  of system that is being developed.
-  A sequential data-processing system is quite different  from an embedded real-time system, so you need to use different types of design models.  The UML supports 13 different types of models, but, as I discussed in Chapter 5, many  of these models are not widely used. Minimizing the number of models that are produced  reduces the costs of the design and the time required to complete the design process.

> [!TIP]
>
> ## ðŸ§± **Purpose of Design (or System) Models**
>
> - They **bridge the gap** between *system requirements* and *implementation*.
> - Should be:
>   - **Abstract enough** to highlight core relationships and logic.
>   - **Detailed enough** to guide programmers in making decisions.
>
> ------
>
> ## ðŸ§° **How Much Detail?**
>
> Depends on:
>
> - **Development process** (Agile vs. Plan-based)
> - **Team structure** (collocated vs. distributed)
> - **System type** (e.g., real-time embedded vs. data-processing)
>
> 
>
> | Process Type      | Design Model Detail         |
> | ----------------- | --------------------------- |
> | Agile             | Minimal, sketch-level       |
> | Plan-based        | Precise, detailed models    |
> | Collocated teams  | Can rely on discussions     |
> | Distributed teams | Need accurate documentation |
>
> ------
>
> ## ðŸ“ **Two Main UML Model Types You Should Use**
>
>  When you use the UML to develop a design, you should develop two kinds of  design models:
>
> ### 1. **Structural Models**
>
>  which describe the static structure of the system using object  classes and their relationships. Important relationships that may be documented  at this stage are generalization (inheritance) relationships, uses/used-by  relationships, and composition relationships.
>
> - Focus: **Static structure**
> - What they show:
>   - Object classes
>   - Relationships:
>     - **Inheritance** (generalization)
>     - **Uses/used-by**
>     - **Composition** (whole-part)
>
> > Represented using **UML class diagrams**
>
> ------
>
> ### 2. **Dynamic Models**
>
>  which describe the dynamic structure of the system and show  the expected runtime interactions between the system objects. Interactions that  may be documented include the sequence of service requests made by objects  and the state changes triggered by these object interactions.
>
> - Focus: **Runtime behavior**
> - What they show:
>   - Object interactions
>   - Event responses
>   - State transitions
> - > Represented using **UML activity, use case,state, sequence diagrams **
>
> ------
>
> ## ðŸ§© **Three Most Useful UML Models for Detailing a Design**
>
>  I think three UML model types are particularly useful for adding detail to use  case and architectural models:
>
> Two types of UML diagrams condition is satisfied -> Structural, Dynamic
>
> | Model Type              | Description                                                  | Structural or Dynamic? |
> | ----------------------- | ------------------------------------------------------------ | ---------------------- |
> | **Subsystem Model**     | Groups related objects into subsystems.                                                               These are represented using a form of class diagram with each subsystem  shown as a package with enclosed objects. | Structural             |
> | **Sequence Model**      | Shows how objects interact over time in a use case. Uses lifelines and messages. These are  represented using a UML sequence or a collaboration diagram. | Dynamic                |
> | **State Machine Model** | Shows object state changes in response to events.                                                These are represented in the UML using state diagrams | Dynamic                |
>
> ------
>
> ## ðŸ§  Summary Tips
>
> - **Decide early** which models to use and how detailed they need to be.
> - **Donâ€™t model everything**â€”just what adds value for communication and understanding.
> - Think in terms of **who will use the model** (designers, developers, testers).



#### <u>Subsystem model</u>

-  A subsystem model is a useful static model that shows how a design is organized into  logically related groups of objects. I have already shown this type of model in Figure 7.4  to present the subsystems in the weather mapping system. As well as  subsystem models,  you may also design detailed object models, showing the objects in the systems and their  associations (inheritance, generalization, aggregation, etc.). However, there is a danger  in doing too much modeling. You should not make detailed decisions about the implementation that are really best left until the system is  implemented

  ![image-20250417131821254](./assets/image-20250417131821254.png)



#### <u>Sequence Model</u>

-  Sequence models (sequence diagrams are drawn for a use case) are dynamic models that describe, for each mode of interaction,  the sequence of object interactions that take place. When documenting a design, you  should produce a sequence model for each significant interaction. If you have developed a use case model, then there should be a sequence model for each use case that  you have identified. 

  - Figure 7.7 is an example of a sequence model, shown as a UML sequence  diagram. This diagram shows the sequence of interactions that take place when an  external system requests the summarized data from the weather station.

    ![image-20250417163506775](./assets/image-20250417163506775.png)

    - The stick arrowhead on the sent message indicates that the external system  does not wait for a reply but can carry on with other processing.
    - WeatherStation sends a message to a Commslink object to summarize the  weather data. In this case, the squared-off style of arrowhead indicates that the  instance of the WeatherStation object class waits for a reply.

  - The **SatComms** and **WeatherStation** objects may be implemented as concurrent  processes, whose execution can be suspended and resumed. The **SatComms** object  instance listens for messages from the external system, decodes these messages, and  initiates weather station operations.

#### <u>State Model</u>

-  Sequence diagrams are used to model the combined behavior of a group of objects,  but you may also want to summarize the behavior of an object or a subsystem in response  to messages and events. To do this, you can use a state machine model that shows how  the object instance changes state depending on the messages that it receives. As I discuss  in Chapter 5, the UML includes state diagrams to describe state machine models.

- Figure 7.8 is a state diagram for the weather station system that shows how it  responds to requests for various services.

  ![image-20250417171358115](./assets/image-20250417171358115.png)

  1. If the system state is Shutdown, then it can respond to a restart(), a reconfigure()  or a powerSave() message. The unlabeled arrow with the black blob indicates  that the Shutdown state is the initial state. A restart() message causes a transition  to normal operation. Both the powerSave() and reconfigure() messages cause a  transition to a state in which the system reconfigures itself. The state diagram  shows that reconfiguration is allowed only if the system has been shut down.
  2. In the Running state, the system expects further messages. If a shutdown() mes sage is received, the object returns to the shutdown state. 
  3.  If a reportWeather() message is received, the system moves to the Summarizing  state. When the summary is complete, the system moves to a Transmitting state where  the information is transmitted to the remote system. It then returns to the Running state.
  4.  If a signal from the clock is received, the system moves to the Collecting state,  where it collects data from the instruments. Each instrument is instructed in turn  to collect its data from the associated sensors. 
  5.  If a remoteControl() message is received, the system moves to a controlled state  in which it responds to a different set of messages from the remote control room.  These are not shown on this diagram.

  State diagrams are useful high-level models of a system or an objectâ€™s operation.  However, you donâ€™t need a state diagram for all of the objects in the system. Many  system objects in a system are simple, and their operation can be easily described  without a state model.

  

## 7.1.5 Interface specification



> [!TIP]
>
> Thought for a couple of seconds
>
> Hereâ€™s a concise breakdown of **Interface Specification** (Section 7.1.5) and how it fits into your UML-based design process:
>
> ------
>
> ## ðŸŽ¯ Purpose of Interface Specification
>
> - **Decouple components** so they can be designed and implemented in parallel.
> - Once an interface is agreed, callers can rely on it even if the implementation changes.
>
> ------
>
> ## ðŸ”§ What to Specify in an Interface
>
> 1. **Operation Signatures**
>    - Method names, parameter types, return types.
>    - No attributes/data representationsâ€”those stay hidden.
> 2. **Semantics**
>    - Use **OCL** (Object Constraint Language) to formally define preâ€‘/postâ€‘conditions, invariants, etc.
>    - Keeps behavior precise without leaking implementation details.
>
> ------
>
> ## ðŸ› ï¸ UML Notation for Interfaces
>
> - Drawn like a class box **without** an attribute section.
> - Stereotype it with Â«interfaceÂ» above the name.
> - List only the operations (signatures) in the compartment.
>
> ```plantuml
> interface Â«interfaceÂ» IWeatherReport {
>     + generateReport(): WeatherReport
>     + reportStatus(): Status
> }
> ```
>
> ------
>
> ## ðŸ”„ Hiding Representation, Exposing Behavior
>
> - **No attributes** in interface: you can swap implementations (e.g., array â†” list) without breaking clients.
> - Always expose **methods** for any data access or update.
>
> ------
>
> ## ðŸ”€ Multiple Views & Group Interfaces
>
> - A single class can **implement** several interfaces, each catering to a different viewpoint.
> - Conversely, you can define an interface thatâ€™s implemented by a **group of classes**, presenting a unified faÃ§ade.
>
> ------
>
> ## ðŸ“ Weather Station Example (Figure 7.9)
>
> | Interface Name             | Purpose                             | Operations Exposed                              |
> | -------------------------- | ----------------------------------- | ----------------------------------------------- |
> | Â«interfaceÂ» IReporting     | Reporting weather & hardware status | + reportWeather(): Data+ reportStatus(): Status |
> | Â«interfaceÂ» IRemoteControl | Sending control commands            | + remoteControl(cmd: String): void              |
>
> - **Mapping:**
>   - `IReporting` methods map 1:1 to `WeatherStation.generateWeatherReport()` and `WeatherStation.reportHardwareStatus()`.
>   - `IRemoteControl` is a single `remoteControl(String cmd)` that encodes four subâ€‘commands internally.
>
> ------
>
> ### ðŸ” Next Steps
>
> - **Draft your interfaces** in UMLâ€”identify who needs to call what.
> - If you want, I can help you write sample OCL constraints for one of these operations, or sketch the actual UML interface boxes for your system. Let me know!

![image-20250417182239911](./assets/image-20250417182239911.png)



# 7.2 Design patterns

<img src="./assets/image-20250525130632880.png" alt="image-20250525130632880" style="zoom:50%;" />

<img src="./assets/image-20250525130655024.png" alt="image-20250525130655024" style="zoom:50%;" />

<img src="./assets/image-20250525130724036.png" alt="image-20250525130724036" style="zoom: 33%;" /> <img src="./assets/image-20250525130748415.png" alt="image-20250525130748415" style="zoom:50%;" />

<img src="./assets/image-20250525130821964.png" alt="image-20250525130821964" style="zoom:67%;" />

<img src="./assets/image-20250525130903151.png" alt="image-20250525130903151" style="zoom:50%;" />

<img src="./assets/image-20250525130959263.png" alt="image-20250525130959263" style="zoom:50%;" />

<img src="./assets/image-20250525131023728.png" alt="image-20250525131023728" style="zoom:67%;" />



now the design part is done , so now we want to talk about implementation. How  we are going to do this? from scratch?, or reusing a similar thing etc

# 7.3 Implementation issues

**Software engineering** involves all activities from initial requirements to system maintenance. A key stage is **implementation**, where an executable version of the software is created. This may involve programming or adapting off-the-shelf systems.

Rather than focusing on language-specific programming practices, this chapter highlights software engineering aspects of implementation often overlooked in programming texts:

1. ==**Reuse**==: Modern software heavily relies on reusing existing components or systems to save time and improve reliability.
2. ==**Configuration Management**==: Managing multiple versions of components is essential to avoid using the wrong version in the final system.
3. ==**Host-Target Development**==: Software is typically developed on one machine (host) and deployed on another (target), which may differ significantly. The host and target systems are sometimes of the same type, but  often they are completely different.



### 1. Reuse

![image-20250525133020033](./assets/image-20250525133020033.png)

<img src="./assets/image-20250525132835539.png" alt="image-20250525132835539" style="zoom:67%;" />

![image-20250525133431065](./assets/image-20250525133431065.png)

##### cons of  reuse

![image-20250525133531701](./assets/image-20250525133531701.png)

![image-20250525133523677](./assets/image-20250525133523677.png)

- How to reuse existing knowledge and software should be the first thing you should  think about when starting a software development project. 
- ==You should consider the  possibilities of reuse <u>before designing the software in detail</u>, as you may wish to adapt  your design to reuse existing software assets.== (in  a  reuse-oriented development process, you search for reusable elements, then modify  your requirements and design to make the best use of these)



### 2. Configuration management

In software development, change is constant, making **configuration management** essential. When multiple developers work on a system, coordination is necessary to avoid conflicts and ensure everyone uses the latest version of components. It's also important to revert to a previous version when issues arise.

Configuration management supports system integration and controlled access to code and documents. The key activities include:

<img src="./assets/image-20250525134515450.png" alt="image-20250525134515450" style="zoom:50%;" />

> [!IMPORTANT]
>
> 1. **Version Management**: Tracks different versions of components and prevents developers from overwriting each other's work. Tools: Git, Subversion.
> 2. **System Integration**: Defines which component versions are used to build the system. This can be automated using build tools like the GNU build system.  support is provided to help developers define what  versions of components are used to create each version of a system. This  description is then used to build a system automatically by compiling and linking the required components.
> 3. **Problem Tracking**: Allows users to report bugs and developers to manage and track issue resolution. Tools: Bugzilla.
> 4. **Release Management**: Manages planning and distribution of new software versions.

These activities are supported by tools integrated into development environments like Eclipse. Platforms like GitHub offer comprehensive toolsets for versioning, integration, and collaboration.



### 3. Host target development

<img src="./assets/image-20250525142826936.png" alt="image-20250525142826936" style="zoom:50%;" />

Most professional software development follows a **host-target model**:

- The **host (development platform)** is where the code is written and tested.
- The **target (execution platform)** is where the software actually runs.
- A platform includes **hardware, OS, and supporting software** (e.g., databases, IDEs).

Sometimes, the host and target are the sameâ€”like when developing Java programs that run on the **Java Virtual Machine (JVM)**, making them portable. But for **embedded or mobile systems**, the host and target are typically different.

------

**Simulators and Testing**

When the target hardware isnâ€™t readily available:

- Developers use **simulators** to mimic sensors, devices, and the environment.
- This speeds up development and allows parallel testing across teams.
- However, simulators are **costly to build** and often exist only for popular hardware.

If the target system uses **middleware or licensed software**, it may not be possible to install it on the host. In such cases, testing must be done directly on the target.

------

**Development Tools & IDEs**

A software development platform typically includes:

1. **Code editors and compilers**
2. **Debugging tools**
3. **Graphical modeling tools** (e.g., UML editors)
4. **Testing frameworks** (e.g., JUnit)
5. **Refactoring and visualization tools**
6. **Version control and build integration** tools

> In team environments, tools may run on **shared servers** supporting version control and requirements management.

These tools are usually integrated into an **IDE (Integrated Development Environment)**:

- IDEs provide a unified interface for all development tasks.
- Some are **language-specific** (e.g., Java IDEs), others are **general-purpose**.
- Example: **Eclipse**, which supports plug-ins for different languages and domains (e.g., embedded systems with C).

------

**Deployment Considerations**

Deployment planning is straightforward for single-device systems like embedded systems. For **distributed systems**, developers must decide where components run based on:

1. > **Hardware/software compatibility** â€“ Components must run on platforms that meet their technical requirements.

2. > **System availability** â€“ Critical components may be duplicated across multiple platforms for redundancy. High-availability systems may require  components to be deployed on more than one platform

3. > **Communication latency** â€“ Components with heavy interaction should be deployed close together (physically) to reduce delays.

**UML deployment diagrams** can help visualize how components are distributed across platforms.

In **embedded system development**, additional considerations include:

- Physical size and power of the target
- Real-time response needs
- Characteristics of sensors and actuators
- The presence of a **real-time operating system (RTOS)**



# 7.4 Open - source development

> [!warning]
>
> ### ðŸ”“ **Open-Source Development â€“ Overview**
>
> Open-source development is a software approach where the **source code is publicly shared**, allowing **anyone to view, use, modify, and contribute**. It started with the **Free Software Foundation**, which promoted software freedom and transparency.
>
> Modern open-source projects use the **Internet to attract global contributors**, many of whom are also users.
>
> ------
>
> ### ðŸ§‘â€ðŸ’» **How It Works**
>
> - A **core team** manages contributions and approves changes.
> - Anyone can **report bugs**, suggest features, or submit code.
> - Projects are hosted on platforms like **GitHub** or **SourceForge**.
>
> ------
>
> ### ðŸ’¡ **Examples of Major Open-Source Software**
>
> - **Linux** (OS for servers)
> - **Apache** (web server)
> - **Android** (mobile OS)
> - **MySQL** (database)
> - **Eclipse** (IDE)
> - Supported by companies like **IBM**, **Oracle**, and **Google**
>
> ------
>
> ### ðŸ’° **Costs and Benefits**
>
> - **Free to download and use**
> - **Paid support/documentation** is optional
> - **Reliable and secure** due to widespread testing and bug reporting
> - Bugs are often **fixed faster** than in closed software
>
> ------
>
> ### ðŸ¢ **Business Use of Open Source**
>
> **Two key decisions for companies:**
>
> 1. Should they **use** open-source components?
> 2. Should they **open-source** their own products?
>
> **Advantages:**
>
> - **Lower cost** and **faster development**
> - Builds a **user community**
> - Helps **small companies** reassure customers (open code means continued access even if the company closes)
>
> **Disadvantages:**
>
> - Might **expose business knowledge** to competitors
> - **Limited contributions** for niche/specialized software
> - **No guaranteed community** â€” many open-source projects fail to attract help
>
> ------
>
> ### ðŸ“‰ **Common Pitfall**
>
> Making a project open source doesnâ€™t ensure success. Most successful projects are **platforms or tools**, not specialized apps. Many open-source projects have few users or contributors.
>
> ------
>
> ### âœ… **Summary**
>
> > Open-source development promotes collaboration and transparency. It can reduce costs and increase software quality, but **success depends on community interest, project relevance, and proper management.**

### Open- Source licensing

> [!CAUTION]
>
> ### ðŸ”“ **Open-Source Licensing â€“ Summary**
>
> Even though open-source software allows free access to source code, it doesn't mean users can do anything they want with it. **Legal ownership and licensing terms still apply**, and different open-source licenses place different **restrictions and freedoms** on use.
>
> ------
>
> ### ðŸ“„ **Common Open-Source Licenses**
>
> 1. **GNU General Public License (GPL)**
>    - **Reciprocal license**
>    - If you use GPL-licensed code, **your software must also be open source**.
>    - Strong restrictions: not ideal for commercial/closed-source products.
> 2. **GNU Lesser GPL (LGPL)**
>    - More permissive than GPL.
>    - You can **link to LGPL code** in proprietary software without open-sourcing your own code.
>    - But if you **modify the LGPL component**, you must open-source those changes.
> 3. **BSD / MIT License**
>    - **Non-reciprocal license** â€“ the most permissive.
>    - You can **use, modify, and include the code in proprietary software**.
>    - You only need to **credit the original authors**.
>
> ------
>
> ### âš ï¸ **Why Licensing Matters**
>
> A **proprietary system** is **software that is owned by an individual or a company** and comes with **restrictions on its use, modification, and distribution**.
>
> - If you plan to **sell software**, using GPL components might force you to **open source your entire project**.
> - LGPL and BSD/MIT are **safer options** for proprietary or commercial products.
> - You must **track licenses** carefully to avoid legal risks.
>
> ------
>
> ### ðŸ¢ **Best Practices for Companies Using Open Source** (Bayersdorfer's suggestions):
>
> 1. **Track components and licenses** â€“ store license copies and monitor changes.
> 2. **Understand license types** before using components.
> 3. **Know how components evolve** â€“ future changes may affect compatibility or usage.
> 4. **Educate your team** about licenses and open-source policies.
> 5. **Implement auditing tools** â€“ prevent accidental license violations under deadlines.
> 6. **Contribute to the open-source community** â€“ builds trust, support, and sustainability.
>
> ------
>
> ### ðŸ’¼ **Open Source as a Business Model**
>
> - Companies may **release source code freely** but **earn money** through:
>   - Paid support or consulting
>   - Specialized versions of the product
>   - **Cloud-based services** built on the software
>
> ------
>
> ### âœ… **Key Takeaway**
>
> > Open-source licensing defines **how freely** you can use, modify, and share code. Understanding these rules is **critical**â€”especially if you're building **commercial or proprietary** systems.
